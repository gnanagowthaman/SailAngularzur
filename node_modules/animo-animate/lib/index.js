var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var VENDOR_TRANSFORMS = ['mozTransform', 'msTransform', 'oTransform', 'transform', 'webkitTransform'];

var VENDOR_TRANSITIONS = ['mozTransition', 'msTransition', 'oTransition', 'transition', 'webkitTransition'];

var VENDOR_PREFIXED_LISTENERS = {
  'animation': {
    animationEnd: 'animationend',
    transitionEnd: 'transitionend'
  },
  'OAnimation': {
    animationEnd: 'oAnimationEnd',
    transitionEnd: 'oTransitionEnd'
  },
  'MozAnimation': {
    animationEnd: 'animationend',
    transitionEnd: 'transitionend'
  },
  'WebkitAnimation': {
    animationEnd: 'webkitAnimationEnd',
    transitionEnd: 'webkitTransitionEnd'
  }
};

var whichVendor = function whichVendor() {
  var el = document.createElement('fakeelement');

  for (var a in VENDOR_PREFIXED_LISTENERS) {
    if (el.style[a] !== undefined) {
      return VENDOR_PREFIXED_LISTENERS[a];
    }

    return VENDOR_PREFIXED_LISTENERS.animation;
  }
};

var animo = function animo(element) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var state = {
    iteration: 0
  };

  var defaultProps = {
    iterate: 1,
    isAnimation: false,
    onComplete: function onComplete() {},
    onIteration: function onIteration() {},
    onMount: function onMount() {}
  };

  return new Promise(function (resolve, reject) {
    if (!element) {
      return reject('could not find element');
    }

    var originalStyles = _extends({}, element.style);
    var props = Object.freeze(_extends({}, defaultProps, options));
    var vendor = whichVendor();
    var animoEl = {
      css: function css(styles) {
        element.setAttribute('style', JSON.stringify(styles));
      },
      reset: function reset() {
        element.setAttribute('style', JSON.stringify(originalStyles));
      },
      transform: function transform(styleString) {
        VENDOR_TRANSFORMS.forEach(function (transform) {
          element.style[transform] = styleString;
        });
      },
      transition: function transition(styleString) {
        VENDOR_TRANSITIONS.forEach(function (transition) {
          element.style[transition] = styleString;
        });
      }
    };

    var performOnMount = function performOnMount() {
      return new Promise(function (resolve, reject) {
        props.onMount(_extends({}, animoEl, { raw: element }));
        // TODO: actually confirm updates rather than
        // delaying and blindly resolving
        setTimeout(function () {
          resolve();
        }, 1);
      });
    };

    var animationStep = function animationStep(event) {
      element.removeEventListener(vendor.transitionEnd, animationStep);

      if (state.iteration === props.iterate) {
        props.onComplete(_extends({}, animoEl, { raw: element }));
        setTimeout(function () {
          resolve(element);
        }, 1);
        return;
      }

      props.onIteration(_extends({}, animoEl, { raw: element }));
      element.addEventListener(vendor.transitionEnd, animationStep);
      state.iteration++;
    };

    if (!props.isAnimation) {
      element.addEventListener(vendor.transitionEnd, animationStep);
    } else {
      element.addEventListener(vendor.animationEnd, function () {
        props.onComplete(_extends({}, animoEl, { raw: element }));
        setTimeout(function () {
          resolve(element);
        }, 1);
        return;
      });
    }

    performOnMount().then(animationStep);
  });
};

var animate = function animate(el, options) {
  var defaultProps = {
    classNames: ['animated'],
    keep: false
  };

  var props = _extends({}, defaultProps, options);

  if (!Array.isArray(props.classNames)) {
    props.classNames = [props.classNames];
  }

  return new animo(el, {
    isAnimation: true,
    onComplete: function onComplete(element) {
      if (!props.keep) {
        props.classNames.forEach(function (classname) {
          el.classList.remove(classname);
        });
      }
    },
    onIteration: function onIteration(element) {
      props.classNames.forEach(function (classname) {
        el.classList.add(classname);
      });
    }
  });
};

export default animate;
