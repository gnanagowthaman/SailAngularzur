{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-dateinputs/dist/es/dateinput/dateinput.component.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-dateinputs/dist/es/dateinput/dateinput.component.js","mtime":1529128639651},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/* tslint:disable:max-line-length */\nimport { Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, Output, ViewChild, EventEmitter, ElementRef, HostBinding, HostListener, isDevMode, Renderer2, forwardRef } from '@angular/core';\nimport { minValidator } from '../validators/min.validator';\nimport { maxValidator } from '../validators/max.validator';\nimport { Keys } from './keys.enum';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nimport { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';\nimport { IntlService } from '@progress/kendo-angular-intl';\nimport { addMonths, cloneDate, createDate, getDate, isEqual, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { approximateStringMatching, guid, noop, isInRange, dateInRange, isValidRange } from '../util';\nimport { Arrow } from './arrow.enum';\nvar MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min';\nvar MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max';\nvar VALUE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json';\nvar DATE_PART_REGEXP = /year|month|<day>/;\nvar TIME_PART_REGEXP = /hour|minute|second|millisecond/;\nvar getTime = function (date) { return date ? date.getTime() : null; };\nvar padZero = function (length) { return new Array(Math.max(length, 0)).fill('0').join(''); };\nvar firstChange = function (change) { return change ? change.firstChange : true; };\nvar Mask = /*@__PURE__*/ (function () {\n    function Mask() {\n        this.symbols = \"\";\n    }\n    return Mask;\n}());\nvar KendoDate = /*@__PURE__*/ (function () {\n    function KendoDate(intl, formatPlaceholder, format, value) {\n        this.intl = intl;\n        this.formatPlaceholder = formatPlaceholder;\n        this.format = format;\n        this.year = true;\n        this.month = true;\n        this.date = true;\n        this.hours = true;\n        this.minutes = true;\n        this.seconds = true;\n        this.milliseconds = true;\n        this.leadingZero = null;\n        this.monthNames = null;\n        this.typedMonthPart = \"\";\n        this.value = getDate(new Date());\n        this.knownParts = \"adHhmMsEy\";\n        this.symbols = {\n            \"E\": \"E\",\n            \"H\": \"H\",\n            \"M\": \"M\",\n            \"a\": \"a\",\n            \"d\": \"d\",\n            \"h\": \"h\",\n            \"m\": \"m\",\n            \"s\": \"s\",\n            \"y\": \"y\"\n        };\n        this.monthNames = this.allFormatedMonths();\n        if (!value) {\n            this.value = getDate(new Date());\n            var sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n            for (var i = 0; i < sampleFormat.length; i++) {\n                this.setExisting(sampleFormat[i], false);\n            }\n        }\n        else {\n            this.value = cloneDate(value);\n        }\n    }\n    KendoDate.prototype.hasValue = function () {\n        var _this = this;\n        var pred = function (a, p) { return a || p.type !== 'literal' && p.type !== 'dayperiod' && _this.getExisting(p.pattern[0]); };\n        return this.intl.splitDateFormat(this.format).reduce(pred, false);\n    };\n    KendoDate.prototype.getDateObject = function () {\n        for (var i = 0; i < this.knownParts.length; i++) {\n            if (!this.getExisting(this.knownParts[i])) {\n                return null;\n            }\n        }\n        return cloneDate(this.value);\n    };\n    KendoDate.prototype.getTextAndFormat = function () {\n        return this.merge(this.intl.formatDate(this.value, this.format), this.dateFormatString(this.value, this.format));\n    };\n    KendoDate.prototype.getExisting = function (symbol) {\n        switch (symbol) {\n            case \"y\": return this.year;\n            case \"M\":\n            case \"L\": return this.month;\n            case \"d\": return this.date;\n            case \"E\": return this.date && this.month && this.year;\n            case \"h\":\n            case \"H\": return this.hours;\n            case \"m\": return this.minutes;\n            case \"s\": return this.seconds;\n            default: return true;\n        }\n    };\n    KendoDate.prototype.setExisting = function (symbol, value) {\n        switch (symbol) {\n            case \"y\":\n                this.year = value;\n                if (value === false) {\n                    this.value.setFullYear(2000);\n                }\n                break; //allow 2/29 dates\n            case \"M\":\n                this.month = value;\n                if (value === false) {\n                    this.value.setMonth(0);\n                }\n                break; //make sure you can type 31 at day part\n            case \"d\":\n                this.date = value;\n                break;\n            case \"h\":\n            case \"H\":\n                this.hours = value;\n                break;\n            case \"m\":\n                this.minutes = value;\n                break;\n            case \"s\":\n                this.seconds = value;\n                break;\n            default: return;\n        }\n    };\n    KendoDate.prototype.modifyPart = function (symbol, offset) {\n        var newValue = cloneDate(this.value);\n        switch (symbol) {\n            case \"y\":\n                newValue.setFullYear(newValue.getFullYear() + offset);\n                break;\n            case \"M\":\n                newValue = addMonths(this.value, offset);\n                break;\n            case \"d\":\n            case \"E\":\n                newValue.setDate(newValue.getDate() + offset);\n                break;\n            case \"h\":\n            case \"H\":\n                newValue.setHours(newValue.getHours() + offset);\n                break;\n            case \"m\":\n                newValue.setMinutes(newValue.getMinutes() + offset);\n                break;\n            case \"s\":\n                newValue.setSeconds(newValue.getSeconds() + offset);\n                break;\n            case \"a\":\n                newValue.setHours(newValue.getHours() + (12 * offset));\n                break;\n            default: break;\n        }\n        if (newValue.getFullYear() > 0) {\n            this.setExisting(symbol, true);\n            this.value = newValue;\n        }\n    };\n    KendoDate.prototype.parsePart = function (symbol, currentChar, resetSegmentValue) {\n        var leadingZero = this.leadingZero || {};\n        this.resetLeadingZero();\n        if (!currentChar) {\n            this.setExisting(symbol, false);\n            return { value: null, switchToNext: false };\n        }\n        var baseDate = this.intl.formatDate(this.value, this.format);\n        var dateParts = this.dateFormatString(this.value, this.format);\n        var baseFormat = dateParts.symbols;\n        var replaced = false;\n        var prefix = \"\";\n        var current = \"\";\n        var suffix = \"\";\n        for (var i = 0; i < baseDate.length; i++) {\n            if (baseFormat[i] === symbol) {\n                current += this.getExisting(symbol) ? baseDate[i] : \"0\";\n                replaced = true;\n            }\n            else if (!replaced) {\n                prefix += baseDate[i];\n            }\n            else {\n                suffix += baseDate[i];\n            }\n        }\n        var currentMaxLength = current.length - 3;\n        var parsedDate = null;\n        var month = this.matchMonth(currentChar);\n        for (var i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n            var middle = resetSegmentValue ? currentChar : (current.substring(i) + currentChar);\n            var middleNumber = parseInt(middle, 10);\n            parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);\n            if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {\n                if (symbol === 'M' && !month) {\n                    var monthNumber = middleNumber - 1;\n                    if (monthNumber > -1 && monthNumber < 12) {\n                        parsedDate = cloneDate(this.value);\n                        parsedDate.setMonth(monthNumber);\n                        if (parsedDate.getMonth() !== monthNumber) {\n                            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                        }\n                    }\n                }\n                if (symbol === 'y') {\n                    parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n                    if (this.date && parsedDate.getDate() !== this.value.getDate()) {\n                        parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                    }\n                }\n            }\n            if (parsedDate) {\n                //move to next segment if the part will overflow with next char\n                //when start from empty date (01, then 010), padded zeros should be trimmed\n                var patternValue = this.partPattern(dateParts.partMap, symbol).pattern;\n                var peekDate = this.intl.parseDate(\"\" + prefix + this.peek(middle, patternValue) + suffix, this.format);\n                this.value = parsedDate;\n                this.setExisting(symbol, true);\n                var switchToNext = peekDate === null || (leadingZero[symbol] && patternValue.length <= middle.length);\n                return { value: this.value, switchToNext: switchToNext };\n            }\n        }\n        if (month) {\n            parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);\n            if (parsedDate) {\n                this.value = parsedDate;\n                this.setExisting(symbol, true);\n                return { value: this.value, switchToNext: false };\n            }\n        }\n        if (currentChar === '0') {\n            this.leadingZero = !this.isAbbrMonth(dateParts.partMap, symbol) ? (_a = {}, _a[symbol] = true, _a) : null;\n            this.setExisting(symbol, false);\n        }\n        return { value: null, switchToNext: false };\n        var _a;\n    };\n    KendoDate.prototype.resetLeadingZero = function () {\n        var hasLeadingZero = this.leadingZero !== null;\n        this.leadingZero = null;\n        return hasLeadingZero;\n    };\n    KendoDate.prototype.isAbbrMonth = function (parts, symbol) {\n        var pattern = this.partPattern(parts, symbol);\n        return pattern.type === 'month' && pattern.names;\n    };\n    KendoDate.prototype.partPattern = function (parts, symbol) {\n        return parts.filter(function (part) { return part.pattern.indexOf(symbol) !== -1; })[0];\n    };\n    KendoDate.prototype.peek = function (value, pattern) {\n        var peekValue = value.replace(/^0*/, '') + '0';\n        return padZero(pattern.length - peekValue.length) + peekValue;\n    };\n    KendoDate.prototype.matchMonth = function (typedChar) {\n        this.typedMonthPart += typedChar.toLowerCase();\n        if (!this.monthNames) {\n            return \"\";\n        }\n        while (this.typedMonthPart.length > 0) {\n            for (var i = 0; i < this.monthNames.length; i++) {\n                if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n                    return this.monthNames[i];\n                }\n            }\n            var monthAsNum = parseInt(this.typedMonthPart, 10);\n            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart /*ensure they exact match*/) {\n                return this.monthNames[monthAsNum - 1];\n            }\n            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n        }\n        return \"\";\n    };\n    KendoDate.prototype.allFormatedMonths = function () {\n        var dateFormatParts = this.intl.splitDateFormat(this.format);\n        for (var i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === \"month\" && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(dateFormatParts[i].names);\n            }\n        }\n        return null;\n    };\n    //TODO: REMOVE!\n    KendoDate.prototype.dateFormatString = function (date, format) {\n        var dateFormatParts = this.intl.splitDateFormat(format);\n        var parts = [];\n        var partMap = [];\n        for (var i = 0; i < dateFormatParts.length; i++) {\n            var partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }).length;\n            while (partLength > 0) {\n                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || \"_\");\n                partMap.push(dateFormatParts[i]);\n                partLength--;\n            }\n        }\n        var returnValue = new Mask();\n        returnValue.symbols = parts.join(\"\");\n        returnValue.partMap = partMap;\n        return returnValue;\n    };\n    KendoDate.prototype.merge = function (text, mask) {\n        // Important: right to left.\n        var resultText = \"\";\n        var resultFormat = \"\";\n        var format = mask.symbols;\n        for (var r = format.length - 1; r >= 0; r--) {\n            if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {\n                resultText = text[r] + resultText;\n                resultFormat = format[r] + resultFormat;\n            }\n            else {\n                var currentSymbol = format[r];\n                while (r >= 0 && currentSymbol === format[r]) {\n                    r--;\n                }\n                r++;\n                if (this.leadingZero && this.leadingZero[currentSymbol]) {\n                    resultText = '0' + resultText;\n                }\n                else {\n                    resultText = this.dateFieldName(mask.partMap[r]) + resultText;\n                }\n                while (resultFormat.length < resultText.length) {\n                    resultFormat = format[r] + resultFormat;\n                }\n            }\n        }\n        return [resultText, resultFormat];\n    };\n    KendoDate.prototype.dateFieldName = function (part) {\n        var formatPlaceholder = this.formatPlaceholder || 'wide';\n        if (formatPlaceholder[part.type]) {\n            return formatPlaceholder[part.type];\n        }\n        if (formatPlaceholder === 'formatPattern') {\n            return part.pattern;\n        }\n        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));\n    };\n    return KendoDate;\n}());\n/**\n * Represents the Kendo UI DateInput component for Angular.\n */\nvar DateInputComponent = /*@__PURE__*/ (function () {\n    function DateInputComponent(cdr, intl, renderer, element, localization) {\n        this.cdr = cdr;\n        this.intl = intl;\n        this.renderer = renderer;\n        this.element = element;\n        this.localization = localization;\n        /**\n         * @hidden\n         */\n        this.id = guid();\n        /**\n         * Sets or gets the `disabled` property of the DateInput and\n         * determines whether the component is active\n         * (see the [basic usage example]({% slug disabled_dateinput %})).\n         */\n        this.disabled = false;\n        /**\n         * Sets or gets the read-only state of the DateInput\n         * (see the [basic usage example]({% slug readonly_dateinput %})).\n         */\n        this.readonly = false;\n        /**\n         * Sets the title of the input element of the DateInput.\n         */\n        this.title = \"\";\n        /**\n         * Sets or gets the `tabIndex` property of the DateInput.\n         * .\n         */\n        this.tabindex = 0;\n        /**\n         * Specifies the date format that is used to display the input value\n         * (see the [basic usage example]({% slug formats_dateinput %})).\n         */\n        this.format = \"d\";\n        /**\n         * Specifies the hint the DateInput displays when its value is `null`.\n         * For more information, refer to the article on\n         * [placeholders]({% slug placeholders_dateinput %}).\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-dateinput placeholder=\"Enter birth date...\"></kendo-dateinput>\n         * `\n         * })\n         * class AppComponent { }\n         * ```\n         */\n        this.placeholder = \"\";\n        /**\n         * Determines whether the built-in min or max validators are to be enforced when a form is being validated.\n         */\n        this.rangeValidation = true;\n        /**\n         * @hidden\n         * Based on the min and max values, specifies whether the value will be auto-corrected while typing.\n         */\n        this.autoCorrect = false;\n        /**\n         * Specifies whether the **Up** and **Down** spin buttons will be rendered.\n         * For more information, refer to the article on\n         * [spinner buttons]({% slug spinbuttons_dateinput %}).\n         */\n        this.spinners = false;\n        /**\n         * @hidden\n         */\n        this.isPopupOpen = false;\n        /**\n         * @hidden\n         */\n        this.hasPopup = false;\n        /**\n         * Fires each time the user selects a new value.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user focuses the input element.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-dateinput (focus)=\"handleFocus()\"></kendo-dateinput>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         *\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the input element gets blurred.\n         * For more information, refer to the section on\n         * [events]({% slug overview_dateinput %}#toc-events).\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-dateinput (blur)=\"handleBlur()\"></kendo-dateinput>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         *\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.arrow = Arrow;\n        this.arrowDirection = Arrow.None;\n        this.formatSections = { date: false, time: false };\n        this.isActive = false;\n        this.currentValue = \"\";\n        this.currentFormat = \"\";\n        this.backspace = false;\n        this.resetSegmentValue = true;\n        this.resolvedPromise = Promise.resolve(null);\n        this.minValidateFn = noop;\n        this.maxValidateFn = noop;\n        this._value = null;\n        this.kendoDate = null;\n        this.ngChange = function (_) { };\n        this.ngTouched = function () { };\n        this.symbolsMap = this.dateSymbolMap();\n        this.updateFormatSections();\n    }\n    Object.defineProperty(DateInputComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateInputComponent.prototype, \"max\", {\n        get: function () {\n            return this._max;\n        },\n        /**\n         * Specifies the biggest date that is valid\n         * (see the [basic usage example]({% slug dateranges_dateinput %})).\n         */\n        set: function (max) {\n            this._max = max;\n            this.ariaValueMax = getTime(max);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateInputComponent.prototype, \"min\", {\n        get: function () {\n            return this._min;\n        },\n        /**\n         * Specifies the smallest date that is valid\n         * (see the [basic usage example]({% slug dateranges_dateinput %})).\n         */\n        set: function (min) {\n            this._min = min;\n            this.ariaValueMin = getTime(min);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateInputComponent.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        /**\n         * Specifies the value of the DateInput component.\n         *\n         * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n         */\n        set: function (value) {\n            this.verifyValue(value);\n            if (this.autoCorrect && !isInRange(value, this.min, this.max)) {\n                return;\n            }\n            this._value = cloneDate(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateInputComponent.prototype, \"wrapperClass\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateInputComponent.prototype, \"disabledClass\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.mousescroll = function (event) {\n        this.handleMouseWheel(event);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.handlePaste = function (event) {\n        event.preventDefault();\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.keydown = function (event) {\n        if (this.disabled || this.readonly || event.altKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.keyCode === Keys.tab) {\n            var moved = this.switchDateSegment(event.shiftKey ? -1 : 1);\n            if (moved) {\n                event.preventDefault();\n            }\n            return;\n        }\n        if (event.keyCode === Keys.backspace) {\n            this.backspace = true;\n            return;\n        }\n        switch (event.keyCode) {\n            case Keys.down:\n                this.modifyDateSegmentValue(-1);\n                break;\n            case Keys.up:\n                this.modifyDateSegmentValue(1);\n                break;\n            case Keys.right:\n                this.switchDateSegment(1);\n                break;\n            case Keys.left:\n                this.switchDateSegment(-1);\n                break;\n            case Keys.home:\n                this.selectNearestSegment(0);\n                break;\n            case Keys.end:\n                this.selectNearestSegment(this.dateInput.nativeElement.value.length);\n                break;\n            default:\n                return; //skip the preventDefault if we didn't handled the keyCode\n        }\n        event.preventDefault();\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.handleInput = function () {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        var diff = approximateStringMatching(this.currentValue, this.currentFormat, this.dateInput.nativeElement.value, this.caret()[0]);\n        var navigationOnly = (diff.length === 1 && diff[0][1] === \"_\");\n        var switchPart = false;\n        if (!navigationOnly) {\n            var parsedPart = void 0;\n            for (var i = 0; i < diff.length; i++) {\n                parsedPart = this.kendoDate.parsePart(diff[i][0], diff[i][1], this.resetSegmentValue);\n                switchPart = parsedPart.switchToNext;\n            }\n        }\n        this.resetSegmentValue = false;\n        this.putDateInRange();\n        this.updateElementValue(this.isActive);\n        this.triggerChange();\n        if (diff.length && diff[0][0] !== \"_\") {\n            this.selectDateSegment(diff[0][0]);\n        }\n        if (switchPart || navigationOnly) {\n            this.switchDateSegment(1);\n        }\n        if (this.backspace) {\n            this.switchDateSegment(-1);\n        }\n        this.backspace = false;\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty\n     */\n    DateInputComponent.prototype.isEmpty = function () {\n        return false;\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        this.verifyRange();\n        if (this.hasChanged(changes, 'min') || this.hasChanged(changes, 'max')) {\n            this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop;\n            this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop;\n            if (!changes.value && (!firstChange(changes.min) || !firstChange(changes.max))) {\n                this.resolvedPromise.then(function () { return _this.ngChange(cloneDate(_this.value)); });\n            }\n        }\n        if (changes.format) {\n            this.symbolsMap = this.dateSymbolMap();\n            this.updateFormatSections();\n        }\n        if (changes.format || this.kendoDate && !isEqual(this.value, this.kendoDate.getDateObject())) {\n            this.writeValue(this.value);\n        }\n    };\n    DateInputComponent.prototype.ngOnDestroy = function () {\n        if (this.intlSubscription) {\n            this.intlSubscription.unsubscribe();\n        }\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.validate = function (control) {\n        return this.minValidateFn(control) || this.maxValidateFn(control);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.ngOnInit = function () {\n        this.renderer.removeAttribute(this.element.nativeElement, 'tabindex');\n        this.kendoDate = this.getKendoDate(this.value);\n        this.updateElementValue();\n        this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n        this.cdr.markForCheck();\n    };\n    //ngModel binding\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.writeValue = function (value) {\n        this.verifyValue(value);\n        this.value = cloneDate(value);\n        this.kendoDate = this.getKendoDate(cloneDate(this.value));\n        this.updateElementValue(this.isActive);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.triggerChange = function () {\n        var dateObject = this.kendoDate.getDateObject();\n        if (+dateObject !== +this.value) {\n            this.value = cloneDate(dateObject);\n            this.ngChange(cloneDate(this.value));\n            this.valueChange.emit(cloneDate(this.value));\n        }\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.registerOnChange = function (fn) {\n        this.ngChange = fn;\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.registerOnTouched = function (fn) {\n        this.ngTouched = fn;\n    };\n    /**\n     * Focuses the DateInput component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"dateinput.focus()\">Focus date input</button>\n     *  <kendo-dateinput #dateinput></kendo-dateinput>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    DateInputComponent.prototype.focus = function () {\n        if (!this.dateInput) {\n            return;\n        }\n        this.dateInput.nativeElement.focus();\n        this.selectDateSegment(this.currentFormat[0]);\n    };\n    /**\n     * Blurs the DateInput component.\n     */\n    DateInputComponent.prototype.blur = function () {\n        if (!this.dateInput) {\n            return;\n        }\n        this.dateInput.nativeElement.blur();\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.handleButtonClick = function (offset) {\n        this.arrowDirection = Arrow.None;\n        this.modifyDateSegmentValue(offset);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.modifyDateSegmentValue = function (offset) {\n        var caret = this.caret();\n        var symbol = this.currentFormat[caret[0]];\n        var step = (this.steps || {})[this.symbolsMap[symbol]] || 1;\n        this.kendoDate.modifyPart(symbol, offset * step);\n        this.putDateInRange();\n        this.updateElementValue(this.isActive);\n        this.triggerChange();\n        this.selectDateSegment(symbol);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.switchDateSegment = function (offset) {\n        var caret = this.caret();\n        if (this.kendoDate.resetLeadingZero()) {\n            this.updateElementValue(this.isActive);\n        }\n        if (caret[0] < caret[1] && this.currentFormat[caret[0]] !== this.currentFormat[caret[1] - 1]) {\n            this.selectNearestSegment(offset > 0 ? caret[0] : caret[1] - 1);\n            this.resetSegmentValue = true;\n            return true;\n        }\n        var previousFormatSymbol = this.currentFormat[caret[0]];\n        var a = caret[0] + offset;\n        while (a > 0 && a < this.currentFormat.length) {\n            if (this.currentFormat[a] !== previousFormatSymbol &&\n                this.currentFormat[a] !== \"_\") {\n                break;\n            }\n            a += offset;\n        }\n        if (this.currentFormat[a] === \"_\") {\n            //there is not known symbol found\n            return false;\n        }\n        var b = a;\n        while (b >= 0 && b < this.currentFormat.length) {\n            if (this.currentFormat[b] !== this.currentFormat[a]) {\n                break;\n            }\n            b += offset;\n        }\n        if (a > b && (b + 1 !== caret[0] || a + 1 !== caret[1])) {\n            this.caret(b + 1, a + 1);\n            this.resetSegmentValue = true;\n            return true;\n        }\n        else if (a < b && (a !== caret[0] || b !== caret[1])) {\n            this.caret(a, b);\n            this.resetSegmentValue = true;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.selectDateSegment = function (symbol) {\n        var begin = -1;\n        var end = 0;\n        for (var i = 0; i < this.currentFormat.length; i++) {\n            if (this.currentFormat[i] === symbol) {\n                end = i + 1;\n                if (begin === -1) {\n                    begin = i;\n                }\n            }\n        }\n        if (begin < 0) {\n            begin = 0;\n        }\n        this.caret(0, 0);\n        this.caret(begin, end);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.handleClick = function () {\n        this.selectNearestSegment(this.caret()[0]);\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.handleFocus = function () {\n        this.isActive = true;\n        this.updateElementValue();\n        this.onFocus.emit();\n    };\n    /**\n     * @hidden\n     */\n    DateInputComponent.prototype.handleBlur = function () {\n        this.isActive = false;\n        this.resetSegmentValue = true;\n        this.updateElementValue();\n        this.ngTouched();\n        this.onBlur.emit();\n    };\n    DateInputComponent.prototype.handleMouseWheel = function (event) {\n        if (this.disabled || this.readonly || !this.isActive) {\n            return;\n        }\n        event = window.event || event;\n        if (event.shiftKey) {\n            this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n        }\n        else {\n            this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n        }\n        event.returnValue = false;\n        if (event.preventDefault) {\n            event.preventDefault();\n        }\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n    };\n    DateInputComponent.prototype.getKendoDate = function (value) {\n        return new KendoDate(this.intl, this.formatPlaceholder, this.format, value);\n    };\n    DateInputComponent.prototype.dateSymbolMap = function () {\n        var reducer = function (map, part) {\n            map[part.pattern[0]] = part.type;\n            return map;\n        };\n        return this.intl.splitDateFormat(this.format).reduce(reducer, {});\n    };\n    DateInputComponent.prototype.updateElementValue = function (isActive) {\n        var start = this.caret()[0]; //XXX: get caret position before input is updated\n        var texts = this.kendoDate.getTextAndFormat();\n        var showPlaceholder = !this.isActive && this.placeholder && !this.kendoDate.hasValue();\n        this.currentFormat = texts[1];\n        this.currentValue = !showPlaceholder ? texts[0] : this.placeholder;\n        this.renderer.setProperty(this.dateInput.nativeElement, \"value\", this.currentValue);\n        var currentDate = this.kendoDate.getDateObject();\n        this.ariaValueNow = getTime(currentDate);\n        this.ariaValueText = this.intl.formatDate(currentDate, this.format);\n        if (isActive) {\n            this.selectNearestSegment(start);\n        }\n    };\n    DateInputComponent.prototype.hasChanged = function (changes, field) {\n        var change = changes[field];\n        return change && !isEqual(change.previousValue, change.currentValue);\n    };\n    DateInputComponent.prototype.caret = function (start, end) {\n        if (end === void 0) {\n            end = start;\n        }\n        var isPosition = start !== undefined;\n        var returnValue = [start, start];\n        var element = this.dateInput.nativeElement;\n        if (isPosition && (this.disabled || this.readonly)) {\n            return undefined;\n        }\n        try {\n            if (element.selectionStart !== undefined) {\n                if (isPosition) {\n                    element.focus();\n                    element.setSelectionRange(start, end);\n                }\n                returnValue = [element.selectionStart, element.selectionEnd];\n            }\n        }\n        catch (e) {\n            returnValue = [];\n        }\n        return returnValue;\n    };\n    DateInputComponent.prototype.selectNearestSegment = function (index) {\n        // Finds the nearest (in both directions) known part.\n        for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n            if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[i]);\n                return;\n            }\n            if (j >= 0 && this.currentFormat[j] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[j]);\n                return;\n            }\n        }\n    };\n    DateInputComponent.prototype.verifyRange = function () {\n        if (!isDevMode()) {\n            return;\n        }\n        if (!isValidRange(this.min, this.max)) {\n            throw new Error(\"The max value should be bigger than the min. See \" + MIN_DOC_LINK + \" and \" + MAX_DOC_LINK + \".\");\n        }\n    };\n    DateInputComponent.prototype.verifyValue = function (value) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (value && !(value instanceof Date)) {\n            throw new Error(\"The 'value' should be a valid JavaScript Date instance. Check \" + VALUE_DOC_LINK + \" for possible resolution.\");\n        }\n    };\n    DateInputComponent.prototype.putDateInRange = function () {\n        var currentDate = this.kendoDate.getDateObject();\n        var candidate = dateInRange(currentDate, this.min, this.max);\n        if (this.autoCorrect && !isEqual(currentDate, candidate)) {\n            this.kendoDate = this.getKendoDate(candidate);\n        }\n    };\n    DateInputComponent.prototype.updateFormatSections = function () {\n        this.formatSections = this.intl.splitDateFormat(this.format)\n            .reduce(function (_a, p) {\n            var date = _a.date, time = _a.time;\n            return {\n                date: date || DATE_PART_REGEXP.test(p.type),\n                time: time || TIME_PART_REGEXP.test(p.type)\n            };\n        }, { date: false, time: false });\n    };\n    DateInputComponent.prototype.intlChange = function () {\n        this.updateFormatSections();\n        this.updateElementValue(this.isActive);\n    };\n    return DateInputComponent;\n}());\nexport { DateInputComponent };\n",null]}