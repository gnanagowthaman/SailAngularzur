{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-inputs/dist/es/slider/utils.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-inputs/dist/es/slider/utils.js","mtime":1529128638504},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { add, subtract, multiply, divide, remainder, fractionLength, toFixedPrecision } from '../common/math';\nfunction elementOffset(element) {\n    var box = element.getBoundingClientRect();\n    var documentElement = document.documentElement;\n    return {\n        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),\n        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)\n    };\n}\nfunction limitValue(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n/**\n * @hidden\n */\nexport function decreaseValueToStep(value, _a, large) {\n    var max = _a.max, min = _a.min, smallStep = _a.smallStep, largeStep = _a.largeStep;\n    if (large === void 0) { large = false; }\n    var step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    var stepValue = subtract(value, min);\n    var result;\n    var stepRemainder = remainder(stepValue, step);\n    if (stepRemainder === 0) {\n        result = subtract(stepValue, step);\n    }\n    else {\n        result = subtract(stepValue, stepRemainder);\n    }\n    return limitValue(add(result, min), min, max);\n}\n/**\n * @hidden\n */\nexport function increaseValueToStep(value, _a, large) {\n    var max = _a.max, min = _a.min, smallStep = _a.smallStep, largeStep = _a.largeStep;\n    if (large === void 0) { large = false; }\n    var step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;\n    var stepValue = subtract(value, min);\n    var stepRemainder = remainder(stepValue, step);\n    var result = add(subtract(stepValue, stepRemainder), step);\n    return limitValue(add(result, min), min, max);\n}\n/**\n * @hidden\n */\nexport function snapValue(value, options) {\n    var smallStep = options.smallStep, min = options.min;\n    var left = decreaseValueToStep(value, options);\n    var right = increaseValueToStep(value, options);\n    if ((value - min) % smallStep === 0) {\n        return value;\n    }\n    if (right - value <= (right - left) / 2) {\n        return right;\n    }\n    return left;\n}\n/**\n * @hidden\n */\nexport function eventValue(eventArgs, scaleElement, options) {\n    var min = options.min, max = options.max, vertical = options.vertical, rtl = options.rtl;\n    var trackOffset = elementOffset(scaleElement);\n    var offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;\n    var scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);\n    var offsetValue = offset * scale;\n    var value = rtl || vertical ? max - offsetValue : min + offsetValue;\n    var stepFractionLength = fractionLength(options.smallStep);\n    value = toFixedPrecision(value, stepFractionLength + 1);\n    return snapValue(value, options);\n}\n/**\n * @hidden\n */\nexport function isButton(element) {\n    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;\n}\n/**\n * @hidden\n */\nexport function isDocumentAvailable() {\n    return typeof document !== 'undefined';\n}\n/**\n * @hidden\n */\nexport function increment(options) {\n    return increaseValueToStep(options.value, options);\n}\n/**\n * @hidden\n */\nexport function decrement(options) {\n    return decreaseValueToStep(options.value, options);\n}\n/**\n * @hidden\n */\nexport function incrementLarge(options) {\n    return increaseValueToStep(options.value, options, true);\n}\n/**\n * @hidden\n */\nexport function decrementLarge(options) {\n    return decreaseValueToStep(options.value, options, true);\n}\n/**\n * @hidden\n */\nexport function calculateValueFromTick(index, _a) {\n    var max = _a.max, min = _a.min, smallStep = _a.smallStep, reverse = _a.reverse, vertical = _a.vertical;\n    var value = add(min, multiply(index, smallStep));\n    return vertical || reverse ? Math.abs(subtract(value, max)) : value;\n}\n/**\n * @hidden\n */\nexport function calculateTicksCount(min, max, smallStep) {\n    if (min === void 0) { min = 0; }\n    if (max === void 0) { max = 0; }\n    if (smallStep === void 0) { smallStep = 1; }\n    if (smallStep <= 0) {\n        throw new Error(\"Invalid argument: smallStep must be a positive number\");\n    }\n    return add(divide(Math.abs(subtract(max, min)), smallStep), 1);\n}\n",null]}