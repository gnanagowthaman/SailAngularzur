{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@telerik/kendo-inputs-common/dist/es/SliderUtil.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@telerik/kendo-inputs-common/dist/es/SliderUtil.js","mtime":1518622023000},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var calculateFixedTrackSize = function (ref) {\n        var max = ref.max;\n        var min = ref.min;\n        var smallStep = ref.smallStep;\n        var fixedTickWidth = ref.fixedTickWidth;\n\n        return ((max - min) / smallStep) * fixedTickWidth;\n};\n\nvar calculateTrackSize = function (wrapperWidth, offset, showButtons) {\n    if ( showButtons === void 0 ) showButtons = true;\n\n    var BUTTONS_COUNT = 2;\n    var trackOffset = showButtons ? parseFloat(offset, 10) * BUTTONS_COUNT : 0;\n    var trackWidth = wrapperWidth - trackOffset;\n\n    return trackWidth;\n};\n\nvar calculateTicksCount = function (max, min, smallStep) {\n        if ( max === void 0 ) max = 0;\n        if ( min === void 0 ) min = 0;\n        if ( smallStep === void 0 ) smallStep = 1;\n\n        return calculateAreasCount(max, min, smallStep) + 1;\n};\n\nvar calculateAreasCount = function (max, min, smallStep) {\n    if ( max === void 0 ) max = 0;\n    if ( min === void 0 ) min = 0;\n    if ( smallStep === void 0 ) smallStep = 1;\n\n    if (smallStep <= 0 ) {\n        throw new Error(\"Invalid argument: smallStep must be a positive number\");\n    }\n\n    return Math.floor(Math.abs(min - max) / smallStep);\n};\n\nvar calculateValueFromTick = function (index, ref) {\n    var max = ref.max;\n    var min = ref.min;\n    var smallStep = ref.smallStep;\n    var reverse = ref.reverse;\n    var vertical = ref.vertical;\n\n    var value = min + (index * smallStep);\n\n    return vertical || reverse ? Math.abs(value - max) : value;\n};\n\nvar calculateValueFromTrack = function (clientRect, pageOffset, props) {\n    var length, wrapperOffset;\n\n    if (props.vertical) {\n        var top = clientRect.top;\n        var bottom = clientRect.bottom;\n        length = top - bottom;\n        wrapperOffset = pageOffset.pageY - bottom;\n    } else {\n        var left = clientRect.left;\n        var right = clientRect.right;\n        length = right - left;\n        wrapperOffset = pageOffset.pageX - left;\n    }\n\n    return valueFromTrack(props, wrapperOffset, length);\n};\n\nvar valueFromTrack = function (props, wrapperOffset, length) {\n    var max = props.max;\n    var min = props.min;\n    var reverse = props.reverse;\n    var smallStep = props.smallStep;\n    var distance = max - min;\n    var clickOffset = wrapperOffset / length;\n    var maxTickValue = distance - (distance % smallStep);\n    var maxOffset = (100 / distance) * maxTickValue / 100;\n    var absValue = (wrapperOffset / length) * distance;\n    var value = max;\n\n    if (clickOffset < maxOffset) {\n        value = reverse ? max - absValue : absValue + min;\n    }\n\n    return snapValue(extendProps(props, { value: value }));\n};\n\nvar calculateTickSizes = function (trackSize, min, max, step) {\n    var elementCount = Math.floor((max - min) / step) + 1;\n    var distStep = trackSize / (max - min);\n    var result = [];\n    var usedSpace = 0;\n    var endPoint = 0;\n\n    for (var i = 0; i < elementCount; i++) {\n        if (i === 0 || i === elementCount - 1) {\n            endPoint += (step / 2) * distStep;\n        } else {\n            endPoint += step * distStep;\n        }\n\n        var size = Math.round(endPoint - usedSpace);\n\n        result.push(size);\n\n        usedSpace += size;\n    }\n\n    return result;\n};\n\nvar calculateHandlePosition = function (ref) {\n    var handleWidth = ref.handleWidth;\n    var trackWidth = ref.trackWidth;\n    var min = ref.min;\n    var max = ref.max;\n    var reverse = ref.reverse;\n    var value = ref.value;\n\n    var halfHandleWidth = Math.floor(handleWidth / 2);\n    var step = trackWidth / Math.abs(max - min);\n    var pos = step * (value - min);\n    if (reverse) {\n        pos = trackWidth - pos;\n    }\n\n    return Math.floor(pos - halfHandleWidth);\n};\n\nvar decreaseValueToStep = function (ref) {\n    var max = ref.max;\n    var min = ref.min;\n    var smallStep = ref.smallStep;\n    var value = ref.value;\n\n    var result;\n    if (value % smallStep === 0) {\n        result = value - smallStep;\n    } else {\n        result = value - (value % smallStep);\n    }\n    return trimValue(max, min, result);\n};\n\nvar increaseValueToStep = function (ref) {\n    var max = ref.max;\n    var min = ref.min;\n    var smallStep = ref.smallStep;\n    var value = ref.value;\n\n    var result = value - (value % smallStep) + smallStep;\n\n    return trimValue(max, min, result);\n};\n\nvar snapValue = function (props) {\n    var smallStep = props.smallStep;\n    var value = props.value;\n    var left = decreaseValueToStep(props);\n    var right = increaseValueToStep(props);\n\n    if (value % smallStep === 0) {\n        return value;\n    }\n\n    if (right - value <= smallStep / 2) {\n        return right;\n    }\n\n    return left;\n};\n\nvar trimValue = function (max, min, value) {\n    if (value > max) {\n        return max;\n    }\n\n    if (value < min) {\n        return min;\n    }\n\n    return value;\n};\n\nvar identity = function (value) { return value; };\n\nvar extendProps = function (target) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return Object.assign.apply(Object, [ {}, target ].concat( sources ));\n};\n\nexport default {\n    calculateFixedTrackSize: calculateFixedTrackSize,\n    calculateValueFromTick: calculateValueFromTick,\n    calculateValueFromTrack: calculateValueFromTrack,\n    calculateTrackSize: calculateTrackSize,\n    calculateTicksCount: calculateTicksCount,\n    calculateTickSizes: calculateTickSizes,\n    calculateHandlePosition: calculateHandlePosition,\n    decreaseValueToStep: decreaseValueToStep,\n    identity: identity,\n    increaseValueToStep: increaseValueToStep,\n    trimValue: trimValue,\n    snapValue: snapValue,\n    valueFromTrack: valueFromTrack\n};\n",null]}