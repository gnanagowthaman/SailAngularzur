{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@telerik/kendo-inputs-common/dist/es/SliderModel.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@telerik/kendo-inputs-common/dist/es/SliderModel.js","mtime":1518622023000},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import SliderUtil from './SliderUtil';\n\nvar SliderModel = function SliderModel(props, wrapper, track) {\n    this.props = props;\n    this.wrapper = wrapper;\n    this.track = track;\n    this.tickSizes = this.getTickSizes();\n};\n\nSliderModel.prototype.getTickSizes = function getTickSizes () {\n    var ref = this.props;\n        var max = ref.max;\n        var min = ref.min;\n        var smallStep = ref.smallStep;\n    var trackWidth = this.trackWidth();\n\n    return SliderUtil.calculateTickSizes(trackWidth, min, max, smallStep);\n};\n\nSliderModel.prototype.trackWidth = function trackWidth () {\n    if (this.props.fixedTickWidth) {\n        return SliderUtil.calculateFixedTrackSize(this.props);\n    }\n\n    return SliderUtil.calculateTrackSize(\n        this.elementSize(this.wrapper),\n        this.elementOffset(this.track),\n        this.props.buttons\n    );\n};\n\nSliderModel.prototype.resizeTrack = function resizeTrack () {\n    var orientation = this.props.vertical ? 'height' : 'width';\n    var trackWidth = this.trackWidth();\n\n    this.track.style[orientation] = trackWidth + \"px\";\n};\n\nSliderModel.prototype.resizeTicks = function resizeTicks (ticksContainer, ticks) {\n        var this$1 = this;\n\n    var dimension = this.props.vertical ? \"height\" : \"width\";\n\n    Array.prototype.slice.call(ticks).map(function (tick, index) { return tick.style[dimension] = (this$1.tickSizes[index]) + \"px\"; });\n\n    if (this.props.vertical) {\n        this.adjustPadding(ticksContainer);\n    }\n};\n\nSliderModel.prototype.resizeWrapper = function resizeWrapper () {\n    var dimension = this.props.vertical ? \"height\" : \"width\";\n    var wrapperSize = this.elementSize(this.wrapper);\n    var trackWidth = SliderUtil.calculateTrackSize(wrapperSize, this.elementOffset(this.track));\n    var fixedTrackWidth = SliderUtil.calculateFixedTrackSize(this.props);\n\n    if (trackWidth > fixedTrackWidth) {\n        this.wrapper.parentElement.style[dimension] = (wrapperSize - (trackWidth - fixedTrackWidth)) + \"px\";\n    } else {\n        this.wrapper.parentElement.style[dimension] = (wrapperSize + (fixedTrackWidth - trackWidth)) + \"px\";\n    }\n};\n\nSliderModel.prototype.positionHandle = function positionHandle (dragHandle) {\n    var ref = this.props;\n        var max = ref.max;\n        var min = ref.min;\n        var reverse = ref.reverse;\n        var vertical = ref.vertical;\n    var position = vertical ? 'bottom' : 'left';\n    var trackWidth = this.trackWidth();\n    var value = SliderUtil.trimValue(max, min, this.props.value);\n\n    this.handlePosition = SliderUtil.calculateHandlePosition({\n        min: min,\n        max: max,\n        reverse: reverse,\n        value: value,\n        trackWidth: trackWidth,\n        handleWidth: dragHandle.offsetWidth\n    });\n\n    dragHandle.style[position] = (this.handlePosition) + \"px\";\n};\n\nSliderModel.prototype.positionSelection = function positionSelection (dragHandle, selection) {\n    var ref = this.props;\n        var reverse = ref.reverse;\n        var vertical = ref.vertical;\n    var dimension = vertical ? 'height' : 'width';\n    var handleWidth = Math.floor(dragHandle.offsetWidth / 2);\n    var size = this.handlePosition + handleWidth;\n\n    if (reverse) {\n        size = this.trackWidth() - size;\n    }\n\n    selection.style[dimension] = size + \"px\";\n};\n\nSliderModel.prototype.adjustPadding = function adjustPadding (ticksContainer) {\n    var totalTickSize = this.tickSizes.reduce(function (prev, curr) { return prev + curr; }, 0);\n    var trackWidth = this.trackWidth();\n    var reminder = trackWidth - totalTickSize;\n\n    if (reminder !== 0) {\n        var padding = reminder + this.elementOffset(this.track);\n        ticksContainer.style.paddingTop = padding + \"px\";\n    }\n};\n\nSliderModel.prototype.elementOffset = function elementOffset (element) {\n    var ref = this.props;\n        var vertical = ref.vertical;\n    var style = getComputedStyle(element);\n\n    return parseInt(vertical ? style.bottom : style.left, 10);\n};\n\nSliderModel.prototype.elementSize = function elementSize (element) {\n    var ref = this.props;\n        var vertical = ref.vertical;\n\n    return vertical ? element.clientHeight : element.clientWidth;\n};\n\nexport default SliderModel;\n",null]}