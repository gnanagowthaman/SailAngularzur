{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-inputs/dist/es/maskedtextbox/maskedtextbox.component.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-inputs/dist/es/maskedtextbox/maskedtextbox.component.js","mtime":1529128637725},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Component, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output, Renderer2, ViewChild, forwardRef } from '@angular/core';\nimport { NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { RTL } from '@progress/kendo-angular-l10n';\nimport { MaskingService } from './masking.service';\nimport { isChanged, anyChanged } from '../common/changes';\nimport { guid } from '../common/dom-utils';\nvar resolvedPromise = Promise.resolve(null);\n/**\n * Represents the Kendo UI MaskedTextBox component for Angular.\n *\n * @example\n * ```ts-preview\n *\n * _@Component({\n *     selector: 'my-app',\n *     template: `\n *      <kendo-maskedtextbox\n *          [mask]=\"mask1\"\n *          [value]=\"value2\">\n *      </kendo-maskedtextbox>\n *     `\n * })\n *\n * class AppComponent {\n *  public value1: number = 9580128055807792;\n *  public mask1: string = \"0000-0000-0000-0000\";\n * }\n * ```\n */\nvar MaskedTextBoxComponent = /*@__PURE__*/ (function () {\n    function MaskedTextBoxComponent(service, renderer, hostElement, rtl) {\n        this.service = service;\n        this.renderer = renderer;\n        this.hostElement = hostElement;\n        /**\n         * @hidden\n         */\n        this.id = guid();\n        /**\n         * Determines whether the component is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Determines whether the MaskedTextBox is in its read-only state.\n         */\n        this.readonly = false;\n        /**\n         * A prompt character for the masked value.\n         * @default `_`\n         */\n        this.prompt = '_';\n        /**\n         * A character representing an empty position in the raw value.\n         * @default ' '\n         */\n        this.promptPlaceholder = ' ';\n        /**\n         * Indicates whether to include literals in the raw value.\n         * @default false\n         */\n        this.includeLiterals = false;\n        /**\n         * Determines whether the built-in mask validator is enforced when validating a form.\n         * @default true\n         */\n        this.maskValidation = true;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Fires each time the user focuses the input element.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (focus)=\"handleFocus()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleFocus(): void {\n         *      console.log(\"Component is focused\");\n         *   }\n         * }\n         * ```\n         *\n         * > To wire the event programmatically, use the `onFocus` property.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the input element gets blurred.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *  <kendo-maskedtextbox (blur)=\"handleBlur()\"></kendo-maskedtextbox>\n         * `\n         * })\n         * class AppComponent {\n         *   public handleBlur(): void {\n         *      console.log(\"Component is blurred\");\n         *   }\n         * }\n         * ```\n         *\n         * > To wire the event programmatically, use the `onBlur` property.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the value changes.\n         */\n        this.valueChange = new EventEmitter();\n        this.focused = false;\n        this.defaultRules = {\n            \"#\": /[\\d\\s\\+\\-]/,\n            \"&\": /[\\S]/,\n            \"0\": /[\\d]/,\n            \"9\": /[\\d\\s]/,\n            \"?\": /[a-zA-Z\\s]/,\n            \"A\": /[a-zA-Z0-9]/,\n            \"C\": /./,\n            \"L\": /[a-zA-Z]/,\n            \"a\": /[a-zA-Z0-9\\s]/\n        };\n        this.isPasted = false;\n        this.selection = [0, 0];\n        this.onChange = function (_) { };\n        this.onTouched = function () { };\n        this.direction = rtl ? 'rtl' : 'ltr';\n        this.updateService();\n        this.hostElement = hostElement.nativeElement;\n    }\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"hostClasses\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"hostFocusedClass\", {\n        get: function () {\n            return this.focused;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"hostDisabledClass\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"rules\", {\n        /**\n         * Exposes the RegExp-based mask validation array.\n         */\n        get: function () {\n            return this._rules || this.defaultRules;\n        },\n        set: function (value) {\n            this._rules = Object.assign({}, this.defaultRules, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MaskedTextBoxComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MaskedTextBoxComponent.prototype.ngOnInit = function () {\n        this.renderer.removeAttribute(this.hostElement, \"tabindex\");\n    };\n    /**\n     * @hidden\n     * Used by the TextBoxContainer to determine if the component is empty.\n     */\n    MaskedTextBoxComponent.prototype.isEmpty = function () {\n        return !this.mask;\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.handleFocus = function (event) {\n        this.focused = true;\n        this.onFocus.emit(event);\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.handleBlur = function (event) {\n        this.focused = false;\n        this.onBlur.emit(event);\n        this.onTouched();\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.handleDragDrop = function () {\n        return false;\n    };\n    /**\n     * Focuses the MaskedTextBox component.\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button (click)=\"maskedinput.focus()\">Focus the input</button>\n     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>\n     * `\n     * })\n     * class AppComponent { }\n     * ```\n     */\n    MaskedTextBoxComponent.prototype.focus = function () {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.focus();\n    };\n    /**\n     * Blurs the MaskedTextBox component.\n     */\n    MaskedTextBoxComponent.prototype.blur = function () {\n        if (!this.input) {\n            return;\n        }\n        this.input.nativeElement.blur();\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.pasteHandler = function (e) {\n        var _a = e.target, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n        if (selectionEnd === selectionStart) {\n            return;\n        }\n        this.isPasted = true;\n        this.selection = [selectionStart, selectionEnd];\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.inputHandler = function (e) {\n        var value = e.target.value;\n        var _a = this.selection, start = _a[0], end = _a[1];\n        if (!this.mask) {\n            this.updateValue(value);\n            this.isPasted = false;\n            return;\n        }\n        var result;\n        if (this.isPasted) {\n            this.isPasted = false;\n            var rightPart = this.maskedValue.length - end;\n            var to = value.length - rightPart;\n            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);\n        }\n        else {\n            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);\n        }\n        this.updateInput(result.value, result.selection);\n        this.updateValue(result.value);\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        if (!this.mask) {\n            this.updateInput(this.value);\n            return;\n        }\n        var next = this.extractChanges(changes);\n        this.updateService(next);\n        if (isChanged('value', changes)) {\n            var maskedValue = this.service.maskRaw(this.value);\n            if (maskedValue !== this.maskedValue) {\n                this.updateInput(maskedValue);\n            }\n        }\n        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {\n            resolvedPromise.then(function () {\n                _this.updateValue(_this.maskedValue);\n            });\n        }\n        else {\n            this.updateInput(this.service.maskRaw(this.value));\n        }\n    };\n    /**\n     * @hidden\n     * Writes a new value to the element.\n     */\n    MaskedTextBoxComponent.prototype.writeValue = function (value) {\n        this.value = value === null ? '' : value;\n        this.updateInput(this.service.maskRaw(this.value));\n    };\n    /**\n     * @hidden\n     * Sets the function that will be called when a `change` event is triggered.\n     */\n    MaskedTextBoxComponent.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * @hidden\n     * Sets the function that will be called when a `touch` event is triggered.\n     */\n    MaskedTextBoxComponent.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    /**\n     * @hidden\n     * Called when the status of the component changes to or from `disabled`.\n     * Depending on the value, it enables or disables the appropriate DOM element.\n     *\n     * @param isDisabled\n     */\n    MaskedTextBoxComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.validate = function (_) {\n        if (this.maskValidation === false || !this.mask) {\n            return null;\n        }\n        if (!this.service.validationValue(this.maskedValue)) {\n            return null;\n        }\n        if (this.maskedValue.indexOf(this.prompt) !== -1) {\n            return {\n                patternError: {\n                    mask: this.mask,\n                    maskedValue: this.maskedValue,\n                    value: this.value\n                }\n            };\n        }\n        return null;\n    };\n    /**\n     * @hidden\n     */\n    MaskedTextBoxComponent.prototype.updateValue = function (maskedValue) {\n        if (this.mask && !this.service.validationValue(maskedValue)) {\n            this.value = '';\n        }\n        else {\n            this.value = this.service.rawValue(maskedValue);\n        }\n        this.onChange(this.value);\n        this.valueChange.emit(this.value);\n    };\n    MaskedTextBoxComponent.prototype.updateInput = function (maskedValue, selection) {\n        if (maskedValue === void 0) {\n            maskedValue = '';\n        }\n        this.maskedValue = maskedValue;\n        this.renderer.setProperty(this.input.nativeElement, \"value\", maskedValue);\n        if (selection !== undefined) {\n            this.input.nativeElement.setSelectionRange(selection, selection);\n        }\n    };\n    MaskedTextBoxComponent.prototype.extractChanges = function (changes) {\n        return Object.keys(changes).filter(function (key) { return key !== 'rules'; }).reduce(function (obj, key) {\n            obj[key] = changes[key].currentValue;\n            return obj;\n        }, {}); // tslint:disable-line:align\n    };\n    MaskedTextBoxComponent.prototype.updateService = function (extra) {\n        var config = Object.assign({\n            includeLiterals: this.includeLiterals,\n            mask: this.mask,\n            prompt: this.prompt,\n            promptPlaceholder: this.promptPlaceholder,\n            rules: this.rules\n        }, extra); // tslint:disable-line:align\n        this.service.update(config);\n    };\n    return MaskedTextBoxComponent;\n}());\nexport { MaskedTextBoxComponent };\n",null]}