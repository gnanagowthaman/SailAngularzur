{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-grid/dist/es/rendering/header/header.component.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-grid/dist/es/rendering/header/header.component.js","mtime":1529128665061},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Component, EventEmitter, HostBinding, Input, Output, QueryList, ViewChildren } from '@angular/core';\nimport { Subscription } from \"rxjs/Subscription\";\nimport { of } from 'rxjs/observable/of';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { merge } from 'rxjs/observable/merge';\nimport { switchMap } from 'rxjs/operators/switchMap';\nimport { switchMapTo } from 'rxjs/operators/switchMapTo';\nimport { tap } from 'rxjs/operators/tap';\nimport { takeUntil } from 'rxjs/operators/takeUntil';\nimport { isColumnComponent } from '../../columns/column.component';\nimport { isColumnGroupComponent } from '../../columns/column-group.component';\nimport { isCheckboxColumn } from '../../columns/column-base';\nimport { normalize } from '../../columns/sort-settings';\nimport { and, isNullOrEmptyString, isPresent, isTruthy, not, observe } from '../../utils';\nimport { columnsToRender, sortColumns, isInSpanColumn } from \"../../columns/column-common\";\nimport { SinglePopupService } from '../../filtering/menu/single-popup.service';\nimport { hasFilterMenu, hasFilterRow } from '../../filtering/filterable';\nimport { IdService } from '../../common/id.service';\nimport { DropTargetDirective } from '../../dragdrop/drop-target.directive';\nimport { DragHintService } from '../../dragdrop/drag-hint.service';\nimport { DropCueService } from '../../dragdrop/drop-cue.service';\nimport { ColumnReorderService } from '../../dragdrop/column-reorder.service';\nimport { position, isTargetBefore, offset } from '../../dragdrop/common';\nvar mergeObjects = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return Object.assign.apply(null, [{}].concat(args));\n};\nvar directions = function (initialDirection) { return initialDirection === \"asc\" ? [\"asc\", \"desc\"] : [\"desc\", \"asc\"]; };\n/**\n * @hidden\n */\nvar isRootLevel = function (_a) {\n    var parent = _a.parent;\n    return !isTruthy(parent);\n};\nvar ofColumnType = function (_a) {\n    var draggable = _a.draggable;\n    return ['column', 'columnGroup']\n        .indexOf(draggable.context.type) >= 0;\n};\nvar notSameElement = function (_a) {\n    var draggable = _a.draggable, target = _a.target;\n    return draggable.element.nativeElement !== target.element.nativeElement;\n};\nvar inSameParent = function (x, y) {\n    return x.parent === y.parent ||\n        (isInSpanColumn(y) && inSameParent(x, y.parent));\n};\nvar sameParent = function (_a) {\n    var draggable = _a.draggable, target = _a.target;\n    return inSameParent(draggable.context.column, target.context.column);\n};\nvar lastNonLocked = function (_a) {\n    var draggable = _a.draggable;\n    return !isTruthy(draggable.context.column.locked) &&\n        isRootLevel(draggable.context.column) &&\n        draggable.context.lastColumn;\n};\nvar notInSpanColumn = function (_a) {\n    var draggable = _a.draggable;\n    return !isInSpanColumn(draggable.context.column);\n};\nvar reorderable = function (_a) {\n    var draggable = _a.draggable;\n    return draggable.context.column.reorderable;\n};\nvar rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked));\n/**\n * @hidden\n */\nvar HeaderComponent = /*@__PURE__*/ (function () {\n    function HeaderComponent(popupService, hint, cue, reorderService, idService) {\n        this.popupService = popupService;\n        this.hint = hint;\n        this.cue = cue;\n        this.reorderService = reorderService;\n        this.idService = idService;\n        this.columns = [];\n        this.groups = [];\n        this.sort = new Array();\n        this.sortable = false;\n        this.groupable = false;\n        this.lockedColumnsCount = 0;\n        this.resizable = false;\n        this.reorderable = false;\n        this.totalColumnsCount = 0;\n        this.sortChange = new EventEmitter();\n        this.dropTargets = new QueryList();\n        this.subscription = new Subscription();\n    }\n    Object.defineProperty(HeaderComponent.prototype, \"headerClass\", {\n        get: function () {\n            return !this.scrollable;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HeaderComponent.prototype, \"unlockedColumnsCount\", {\n        // Number of unlocked columns in the next table, if any\n        get: function () {\n            return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HeaderComponent.prototype.sortColumn = function (column, event, link, icon) {\n        var target = event ? event.target : null;\n        if (column.headerTemplateRef && target !== link && target !== icon) {\n            return false;\n        }\n        this.sortChange.emit(this.toggleSort(column));\n        //prevent default\n        return false;\n    };\n    HeaderComponent.prototype.showSortNumbering = function (column) {\n        var showIndexes = normalize(this.sortable).showIndexes;\n        return showIndexes\n            && this.sort\n            && this.sort.filter(function (_a) {\n                var dir = _a.dir;\n                return isPresent(dir);\n            }).length > 1\n            && this.sortOrder(column.field) > 0;\n    };\n    HeaderComponent.prototype.sortOrder = function (field) {\n        return this.sort\n            .filter(function (_a) {\n            var dir = _a.dir;\n            return isPresent(dir);\n        })\n            .findIndex(function (x) { return x.field === field; })\n            + 1;\n    };\n    HeaderComponent.prototype.sortIcon = function (field) {\n        var state = this.sortDescriptor(field);\n        return {\n            'k-icon': isPresent(state.dir),\n            'k-i-sort-desc-sm': state.dir === \"desc\",\n            'k-i-sort-asc-sm': state.dir === \"asc\"\n        };\n    };\n    HeaderComponent.prototype.toggleSort = function (column) {\n        var _a = normalize(this.sortable, column.sortable), allowUnsort = _a.allowUnsort, mode = _a.mode, initialDirection = _a.initialDirection;\n        var descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);\n        if (mode === 'single') {\n            return [descriptor];\n        }\n        return this.sort.filter(function (desc) { return desc.field !== column.field; }).concat([descriptor]);\n    };\n    HeaderComponent.prototype.ngAfterViewInit = function () {\n        this.subscription.add(observe(this.dropTargets)\n            .subscribe(this.attachTargets.bind(this)));\n    };\n    HeaderComponent.prototype.ngOnDestroy = function () {\n        if (this.targetSubscription) {\n            this.targetSubscription.unsubscribe();\n        }\n        if (this.popupService) {\n            this.popupService.destroy();\n        }\n    };\n    HeaderComponent.prototype.selectAllCheckboxId = function () {\n        return this.idService.selectAllCheckboxId();\n    };\n    HeaderComponent.prototype.isFirstOnRow = function (column, index) {\n        var _this = this;\n        var isTailing = function (c) {\n            return c &&\n                (_this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));\n        };\n        return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);\n    };\n    HeaderComponent.prototype.leafColumnIndex = function (column) {\n        return this.leafColumns.indexOf(column);\n    };\n    Object.defineProperty(HeaderComponent.prototype, \"showFilterMenu\", {\n        get: function () {\n            return hasFilterMenu(this.filterable);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HeaderComponent.prototype, \"showFilterRow\", {\n        get: function () {\n            return hasFilterRow(this.filterable);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HeaderComponent.prototype.isFilterable = function (column) {\n        return !isNullOrEmptyString(column.field) && column.filterable === true;\n    };\n    HeaderComponent.prototype.canDrop = function (draggable, target) {\n        return this.reorderable && rules({ draggable: draggable, target: target });\n    };\n    HeaderComponent.prototype.shouldActivate = function (column) {\n        var canReorder = this.reorderable && column.reorderable;\n        if (!canReorder && !isColumnComponent(column)) {\n            return false;\n        }\n        var groupable = this.groupable && isColumnComponent(column) && column.groupable !== false;\n        return groupable || canReorder;\n    };\n    HeaderComponent.prototype.isSortable = function (column) {\n        return !isNullOrEmptyString(column.field)\n            && isTruthy(this.sortable) && isTruthy(column.sortable);\n    };\n    HeaderComponent.prototype.isCheckboxColumn = function (column) {\n        return isCheckboxColumn(column) && !column.templateRef;\n    };\n    HeaderComponent.prototype.toggleDirection = function (field, allowUnsort, initialDirection) {\n        var descriptor = this.sortDescriptor(field);\n        var _a = directions(initialDirection), first = _a[0], second = _a[1];\n        var dir = first;\n        if (descriptor.dir === first) {\n            dir = second;\n        }\n        else if (descriptor.dir === second && allowUnsort) {\n            dir = undefined;\n        }\n        return { dir: dir, field: field };\n    };\n    HeaderComponent.prototype.columnsForLevel = function (level) {\n        var columns = this.columns ? this.columns.filter(function (column) { return column.level === level; }) : [];\n        return sortColumns(columnsToRender(columns));\n    };\n    HeaderComponent.prototype.isColumnGroupComponent = function (column) {\n        return isColumnGroupComponent(column);\n    };\n    Object.defineProperty(HeaderComponent.prototype, \"columnLevels\", {\n        get: function () {\n            return new Array((this.totalColumnLevels || 0) + 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HeaderComponent.prototype.sortDescriptor = function (field) {\n        return this.sort.find(function (item) { return item.field === field; }) || { field: field };\n    };\n    Object.defineProperty(HeaderComponent.prototype, \"leafColumns\", {\n        get: function () {\n            return columnsToRender(this.columns || []).filter(function (x) { return !isColumnGroupComponent(x); });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HeaderComponent.prototype.attachTargets = function () {\n        var _this = this;\n        if (this.targetSubscription) {\n            this.targetSubscription.unsubscribe();\n        }\n        this.targetSubscription = new Subscription();\n        var enterStream = merge.apply(void 0, this.dropTargets.map(function (target) { return target.enter; }));\n        var leaveStream = merge.apply(void 0, this.dropTargets.map(function (target) { return target.leave; }));\n        var dropStream = merge.apply(void 0, this.dropTargets.map(function (target) { return target.drop; }));\n        this.targetSubscription.add(enterStream.pipe(tap(function (_a) {\n            var target = _a.target, draggable = _a.draggable;\n            if (draggable.context.type === 'groupIndicator') {\n                return;\n            }\n            var targetLocked = isTruthy(target.context.column.isLocked);\n            var draggableLocked = isTruthy(draggable.context.column.isLocked);\n            if (_this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {\n                _this.hint.toggleLock(targetLocked);\n            }\n        }), filter(function (_a) {\n            var draggable = _a.draggable, target = _a.target;\n            return _this.canDrop(draggable, target);\n        }), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map(function (e) { return mergeObjects(e, { before: _this.calculateBefore(e) }); }), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))), function (outerArgs, _) { return outerArgs; }))\n            .subscribe(this.drop.bind(this)));\n    };\n    HeaderComponent.prototype.normalizeTarget = function (e) {\n        var target = e.target;\n        var parent = target.context.column.parent;\n        if (parent && parent.isSpanColumn) {\n            var arr = this.dropTargets.toArray();\n            var firstSpan = arr.find(function (t) { return t.context.column.parent === parent; });\n            var index = arr.indexOf(firstSpan);\n            var adjust = e.before ? 0 : parent.childColumns.length - 1;\n            target = arr[index + adjust];\n        }\n        return mergeObjects(e, { target: target });\n    };\n    HeaderComponent.prototype.trackMove = function (leaveStream, dropStream, e) {\n        var column = e.target.context.column;\n        var levelColumns = this.columnsForLevel(column.level);\n        var index = levelColumns.indexOf(column);\n        var isFirst = (column.locked ? index === levelColumns.length - 1 : index === 0);\n        var changed = e.draggable.context.column.isLocked !== column.isLocked;\n        if (changed && isFirst) {\n            return e.draggable.drag\n                .pipe(takeUntil(leaveStream), takeUntil(dropStream), map(function (_a) {\n                var mouseEvent = _a.mouseEvent;\n                return mergeObjects({ changeContainer: true }, e, { mouseEvent: mouseEvent });\n            }));\n        }\n        return of(e);\n    };\n    HeaderComponent.prototype.calculateBefore = function (_a) {\n        var draggable = _a.draggable, target = _a.target, mouseEvent = _a.mouseEvent, _b = _a.changeContainer, changeContainer = _b === void 0 ? false : _b;\n        var targetElement = target.element.nativeElement;\n        var before = false;\n        if (changeContainer) {\n            var left = offset(targetElement).left;\n            var halfWidth = targetElement.offsetWidth / 2;\n            var middle = left + halfWidth;\n            before = middle > mouseEvent.pageX;\n        }\n        else {\n            before = isTargetBefore(draggable.element.nativeElement, targetElement);\n        }\n        return before;\n    };\n    HeaderComponent.prototype.enter = function (_a) {\n        var target = _a.target, before = _a.before;\n        this.hint.enable();\n        this.cue.position(position(target.element.nativeElement, before));\n    };\n    HeaderComponent.prototype.leave = function () {\n        this.hint.disable();\n        this.cue.hide();\n    };\n    HeaderComponent.prototype.drop = function (_a) {\n        var draggable = _a.draggable, target = _a.target, before = _a.before;\n        this.reorderService.reorder({\n            before: before,\n            source: draggable.context.column,\n            target: target.context.column\n        });\n    };\n    return HeaderComponent;\n}());\nexport { HeaderComponent };\n",null]}