{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-dateinputs/dist/es/virtualization/virtualization.component.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-dateinputs/dist/es/virtualization/virtualization.component.js","mtime":1529128648167},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/* tslint:disable:component-selector-name  component-selector-type */\nimport { Component, ChangeDetectionStrategy, EventEmitter, ElementRef, HostBinding, Input, Inject, Output, InjectionToken, Renderer2, NgZone } from '@angular/core';\nimport { RowHeightService } from './services/row-height.service';\nimport { ScrollerService, PageAction } from './services/scroller.service';\nimport { isDocumentAvailable } from '../util';\nimport { animationFrame } from 'rxjs/scheduler/animationFrame';\nimport { Subject } from 'rxjs/Subject';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { interval } from 'rxjs/observable/interval';\nimport { empty } from 'rxjs/observable/empty';\nimport { of } from 'rxjs/observable/of';\nimport { combineLatest } from 'rxjs/operators/combineLatest';\nimport { map } from 'rxjs/operators/map';\nimport { scan } from 'rxjs/operators/scan';\nimport { takeWhile } from 'rxjs/operators/takeWhile';\n/**\n * @hidden\n */\nexport var SCROLLER_FACTORY_TOKEN = new InjectionToken('dateinputs-scroll-service-factory');\n/**\n * @hidden\n */\nexport function DEFAULT_SCROLLER_FACTORY(observable) {\n    return new ScrollerService(observable);\n}\n/**\n * @hidden\n */\nexport var ScrollDirection = /*@__PURE__*/ (function (ScrollDirection) {\n    ScrollDirection[ScrollDirection[\"Up\"] = 0] = \"Up\";\n    ScrollDirection[ScrollDirection[\"Down\"] = 1] = \"Down\";\n    return ScrollDirection;\n})({});\nvar FRAME_DURATION = 17;\nvar scrollModifiers = (_a = {},\n    _a[ScrollDirection.Down] = function (step) { return function (value) { return value + step; }; },\n    _a[ScrollDirection.Up] = function (step) { return function (value) { return value - step; }; },\n    _a);\nvar scrollNormalizers = (_b = {},\n    _b[ScrollDirection.Down] = function (end) { return function (value) { return Math.min(value, end); }; },\n    _b[ScrollDirection.Up] = function (end) { return function (value) { return Math.max(value, end); }; },\n    _b);\nvar scrollValidators = (_c = {},\n    _c[ScrollDirection.Down] = function (end) { return function (start) { return start < end; }; },\n    _c[ScrollDirection.Up] = function (end) { return function (start) { return start > end; }; },\n    _c);\nvar differenceToScroll = function (scrollTop, staticOffset, maxScrollDifference) {\n    return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);\n};\n/**\n * @hidden\n */\nvar VirtualizationComponent = /*@__PURE__*/ (function () {\n    function VirtualizationComponent(scrollerFactory, container, renderer, zone) {\n        this.container = container;\n        this.renderer = renderer;\n        this.zone = zone;\n        this.itemHeight = 1;\n        this.topOffset = 0;\n        this.bottomOffset = 0;\n        this.maxScrollDifference = 100;\n        this.scrollOffsetHeight = 0;\n        this.scrollDuration = 150;\n        this.activeIndexChange = new EventEmitter();\n        this.pageChange = new EventEmitter();\n        this.scrollChange = new EventEmitter();\n        this.resolvedPromise = Promise.resolve(null);\n        this.dispatcher = new Subject();\n        this.scroller = scrollerFactory(this.dispatcher);\n    }\n    VirtualizationComponent.prototype.wrapperClasses = function () {\n        return true;\n    };\n    VirtualizationComponent.prototype.ngOnChanges = function (changes) {\n        if (changes.take || changes.total) {\n            this.initServices();\n            this.totalHeight = this.getTotalHeight();\n        }\n    };\n    VirtualizationComponent.prototype.ngOnInit = function () {\n        if (!this.rowHeightService) {\n            this.rowHeightService = this.createRowHeightService();\n        }\n    };\n    VirtualizationComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.zone.runOutsideAngular(function () {\n            _this.containerScrollSubscription = _this.scroll$()\n                .pipe(map(function (event) { return event.target; }))\n                .subscribe(function (t) {\n                _this.dispatcher.next(t);\n                _this.emitActiveIndex(t);\n            });\n        });\n    };\n    VirtualizationComponent.prototype.ngOnDestroy = function () {\n        if (this.containerScrollSubscription) {\n            this.containerScrollSubscription.unsubscribe();\n        }\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n        }\n        if (this.animationSubscription) {\n            this.animationSubscription.unsubscribe();\n        }\n    };\n    VirtualizationComponent.prototype.activeIndex = function () {\n        return this.itemIndex(Math.ceil(this.container.nativeElement.scrollTop)); //handle subpixeling\n    };\n    VirtualizationComponent.prototype.itemIndex = function (offset) {\n        return this.rowHeightService.index(offset);\n    };\n    VirtualizationComponent.prototype.itemOffset = function (index) {\n        return this.rowHeightService.offset(index);\n    };\n    VirtualizationComponent.prototype.isIndexVisible = function (index) {\n        if (!this.rowHeightService) {\n            return false;\n        }\n        var currentScrollTop = this.container.nativeElement.scrollTop;\n        var top = this.rowHeightService.offset(index);\n        var bottom = top + this.rowHeightService.height(index);\n        return currentScrollTop >= top && currentScrollTop <= bottom;\n    };\n    VirtualizationComponent.prototype.isListScrolled = function (index) {\n        return this.container.nativeElement.scrollTop !== this.rowHeightService.offset(index);\n    };\n    VirtualizationComponent.prototype.scrollTo = function (value) {\n        this.renderer.setProperty(this.container.nativeElement, 'scrollTop', value);\n    };\n    VirtualizationComponent.prototype.scrollToIndex = function (index) {\n        var _this = this;\n        //XXX: scrolling with tick is required to prevent list jump in Chrome.\n        //Original issue: focus first day in the month and press LEFT arrow.\n        //Notice how the view jumps on every day change.\n        //\n        this.resolvedPromise.then(function () {\n            _this.scrollTo(_this.rowHeightService.offset(index));\n        });\n    };\n    VirtualizationComponent.prototype.scrollToBottom = function () {\n        this.scrollTo(this.totalHeight);\n    };\n    VirtualizationComponent.prototype.animateToIndex = function (index) {\n        var _this = this;\n        if (this.animationSubscription) {\n            this.animationSubscription.unsubscribe();\n        }\n        var indexOffset = this.rowHeightService.offset(index);\n        var direction = this.getScrollDirection(indexOffset);\n        var _a = this.scrollRange(indexOffset, direction), start = _a.start, end = _a.end;\n        if (start === end) {\n            return;\n        }\n        var step = this.scrollStep(start, end);\n        var modifyScroll = scrollModifiers[direction](step);\n        var normalizeScroll = scrollNormalizers[direction](end);\n        var isScrollValid = scrollValidators[direction](modifyScroll(end));\n        this.zone.runOutsideAngular(function () {\n            _this.animationSubscription = of(start)\n                .pipe(combineLatest(interval(0, animationFrame)), map(function (stream) { return stream[0]; }), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll))\n                .subscribe(function (x) { return _this.scrollTo(x); });\n        });\n    };\n    VirtualizationComponent.prototype.scrollRange = function (indexOffset, direction) {\n        var containerScrollTop = this.container.nativeElement.scrollTop;\n        if (parseInt(indexOffset, 10) === parseInt(containerScrollTop, 10)) {\n            return { start: indexOffset, end: indexOffset };\n        }\n        var max = this.containerMaxScroll();\n        var sign = direction === ScrollDirection.Up ? 1 : -1;\n        var difference = differenceToScroll(containerScrollTop, indexOffset, this.maxScrollDifference);\n        var end = Math.min(indexOffset, max);\n        var start = Math.min(Math.max(end + (sign * difference), 0), max);\n        return { start: start, end: end };\n    };\n    VirtualizationComponent.prototype.scrollStep = function (start, end) {\n        return Math.abs(end - start) / (this.scrollDuration / FRAME_DURATION);\n    };\n    VirtualizationComponent.prototype.scroll$ = function () {\n        return isDocumentAvailable() ? fromEvent(this.container.nativeElement, 'scroll') : empty();\n    };\n    VirtualizationComponent.prototype.initServices = function () {\n        var _this = this;\n        this.rowHeightService = this.createRowHeightService();\n        if (this.scrollSubscription) {\n            this.scrollSubscription.unsubscribe();\n        }\n        this.scrollSubscription = this.scroller\n            .create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetHeight)\n            .subscribe(function (x) {\n            return _this.zone.run(function () {\n                if (x instanceof PageAction) {\n                    _this.pageChange.emit(x);\n                }\n                else {\n                    _this.scrollChange.emit(x);\n                }\n            });\n        });\n    };\n    VirtualizationComponent.prototype.createRowHeightService = function () {\n        return new RowHeightService(this.total, this.itemHeight, 0);\n    };\n    VirtualizationComponent.prototype.getTotalHeight = function () {\n        return this.rowHeightService.totalHeight() + this.bottomOffset;\n    };\n    VirtualizationComponent.prototype.emitActiveIndex = function (_a) {\n        var scrollTop = _a.scrollTop;\n        var index = this.rowHeightService.index(scrollTop - this.topOffset);\n        if (this.lastActiveIndex !== index) {\n            this.lastActiveIndex = index;\n            this.activeIndexChange.emit(index);\n        }\n    };\n    VirtualizationComponent.prototype.getScrollDirection = function (indexOffset) {\n        return indexOffset < this.container.nativeElement.scrollTop ? ScrollDirection.Up : ScrollDirection.Down;\n    };\n    VirtualizationComponent.prototype.containerMaxScroll = function () {\n        var containerElement = this.container.nativeElement;\n        return containerElement.scrollHeight - containerElement.offsetHeight;\n    };\n    return VirtualizationComponent;\n}());\nexport { VirtualizationComponent };\nvar _a, _b, _c;\n",null]}