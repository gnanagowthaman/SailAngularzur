{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-grid/dist/es/grouping/group-scroll-binding.directive.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-angular-grid/dist/es/grouping/group-scroll-binding.directive.js","mtime":1529128654870},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import * as tslib_1 from \"tslib\";\nimport { Directive, Input } from '@angular/core';\nimport { DataBindingDirective } from \"../databinding.directive\";\nimport { GridComponent } from \"../grid.component\";\nimport { filterBy, process } from \"@progress/kendo-data-query\";\nimport { isPresent, isArray } from \"../utils\";\nimport { diffFilters, cloneFilters } from \"../common/filter-descriptor-differ\";\nimport { LocalDataChangesService } from \"../editing/local-data-changes.service\";\nvar hasGroups = function (items) { return items && items.length && items[0].field && items[0].items; };\nvar processGroups = function (data, state) { return process(data, state).data; };\nvar removeParentDescriptors = function (parents, owner) { return function (g) { return g.field !== owner.field && !parents.some(function (y) { return y.field === g.field; }); }; };\nvar findGroup = function (groupIndex, groups) {\n    var parents = [];\n    return {\n        group: groupIndex.split(\"_\").reduce(function (acc, x) {\n            var idx = parseInt(x, 10);\n            if (acc.items) {\n                parents.push(acc);\n                return acc.items[idx];\n            }\n            return isArray(acc) ? acc[idx] : acc;\n        }, groups),\n        parents: parents\n    };\n};\nvar findChildren = function (data, parents) {\n    var filters = parents.map(function (p) { return ({ field: p.field, operator: \"eq\", value: p.value }); });\n    return filterBy(data, {\n        filters: filters,\n        logic: \"and\"\n    });\n};\n/**\n * @hidden\n */\nexport var count = function (groups, includeFooters) {\n    if (includeFooters === void 0) {\n        includeFooters = false;\n    }\n    return (groups.reduce(function (acc, group) {\n        if (!group.skipHeader) {\n            acc++;\n        }\n        if (group.items) {\n            var children = count(group.items, includeFooters);\n            if (includeFooters && children && !group.hideFooter) {\n                acc++;\n            }\n            acc += children;\n        }\n        return acc;\n    }, 0) // tslint:disable-line:align\n    );\n};\n/**\n * @hidden\n */\nexport var slice = function (groups, skip, take, includeFooters) {\n    if (includeFooters === void 0) {\n        includeFooters = false;\n    }\n    if (!isPresent(take)) {\n        return groups;\n    }\n    var result = [];\n    for (var idx = 0, length_1 = groups.length; idx < length_1; idx++) {\n        if (take <= 0) {\n            break;\n        }\n        var group = groups[idx];\n        var groupItems = group.items;\n        var itemCount = count(groupItems, includeFooters);\n        if (includeFooters && groupItems.length) {\n            itemCount++;\n        }\n        var skipHeader = skip > 0;\n        if (skip) {\n            skip--;\n            if (itemCount && skip >= itemCount) {\n                skip -= itemCount;\n                continue;\n            }\n        }\n        if (!skipHeader || itemCount) {\n            var items = [];\n            var hideFooter = true;\n            if (!skipHeader) {\n                take--;\n            }\n            if (take) {\n                if (hasGroups(groupItems)) {\n                    var children = slice(groupItems, skip, take, includeFooters);\n                    items.push.apply(items, children);\n                    take -= count(children, includeFooters);\n                }\n                else {\n                    items.push.apply(items, groupItems.slice(skip, Math.min(skip + take, groupItems.length)));\n                    take -= items.length;\n                }\n                if (take && includeFooters) {\n                    hideFooter = false;\n                    take--;\n                }\n                skip = 0;\n            }\n            result.push({\n                aggregates: group.aggregates,\n                field: group.field,\n                hideFooter: hideFooter,\n                items: items,\n                offset: idx,\n                skipHeader: skipHeader,\n                value: group.value\n            });\n        }\n    }\n    return result;\n};\n/**\n * A directive which encapsulates the in-memory handling of grouping with virtual scrolling.\n */\nvar GroupBindingDirective = (function (_super) {\n    tslib_1.__extends(GroupBindingDirective, _super);\n    function GroupBindingDirective(grid, localDataChangesService) {\n        return _super.call(this, grid, localDataChangesService) || this;\n    }\n    Object.defineProperty(GroupBindingDirective.prototype, \"kendoGridGroupBinding\", {\n        /**\n         * The array of data which will be used to populate the Grid.\n         */\n        set: function (value) {\n            this.groups = null;\n            this.grid.resetGroupsState();\n            this.data = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupBindingDirective.prototype, \"data\", {\n        /**\n         * @hidden\n         */\n        set: function (value) {\n            this.originalData = value || [];\n            this.grid.data = this.process(this.state);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupBindingDirective.prototype, \"sort\", {\n        /**\n         * Defines the descriptors by which the data will be sorted.\n         */\n        set: function (value) {\n            var clear = this.state.sort !== value;\n            this.grid.sort = this.state.sort = value;\n            if (clear) {\n                this.groups = null;\n                this.grid.resetGroupsState();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupBindingDirective.prototype, \"filter\", {\n        /**\n         * Defines the descriptor by which the data will be filtered.\n         */\n        set: function (value) {\n            var clear = diffFilters(this.state.filter, value);\n            if (clear) {\n                this.state.filter = value;\n                this.grid.filter = isPresent(value) ? cloneFilters(value) : value;\n                this.groups = null;\n                this.grid.resetGroupsState();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupBindingDirective.prototype, \"group\", {\n        /**\n         * Defines the descriptors by which the data will be grouped.\n         */\n        set: function (value) {\n            var clear = this.state.group !== value;\n            this.grid.group = this.state.group = value;\n            if (clear) {\n                this.groups = null;\n                this.grid.resetGroupsState();\n                this.skip = 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    GroupBindingDirective.prototype.ngOnInit = function () {\n        _super.prototype.ngOnInit.call(this);\n        this.grid.groupExpand.subscribe(this.groupExpand.bind(this));\n        this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this));\n    };\n    GroupBindingDirective.prototype.groupExpand = function (_a) {\n        var groupIndex = _a.groupIndex;\n        this.grid.expandGroupChildren(groupIndex);\n        var _b = findGroup(groupIndex, this.groups), group = _b.group, parents = _b.parents;\n        if (!group.items.length) {\n            var descriptors = this.state.group.filter(removeParentDescriptors(parents, group));\n            var children = findChildren(this.originalData, parents.concat(group));\n            group.items = processGroups(children, {\n                filter: this.state.filter,\n                group: descriptors,\n                sort: this.state.sort\n            });\n        }\n        this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    };\n    GroupBindingDirective.prototype.groupCollapse = function (_a) {\n        var groupIndex = _a.groupIndex;\n        var group = findGroup(groupIndex, this.groups).group;\n        if (group) {\n            group.items = [];\n        }\n        this.grid.data = this.dataResult(this.state.skip, this.state.take);\n    };\n    GroupBindingDirective.prototype.process = function (state) {\n        if (state.group && state.group.length) {\n            return this.processGroups(state);\n        }\n        else {\n            this.groups = null;\n        }\n        return _super.prototype.process.call(this, state);\n    };\n    GroupBindingDirective.prototype.processGroups = function (state) {\n        if (!this.groups || !this.groups.length) {\n            this.groups = processGroups(this.originalData, {\n                filter: state.filter,\n                group: state.group,\n                sort: state.sort\n            });\n        }\n        return this.dataResult(state.skip, state.take);\n    };\n    GroupBindingDirective.prototype.dataResult = function (skip, take) {\n        var includeFooters = this.grid.showGroupFooters;\n        return {\n            data: slice(this.groups, skip, take, includeFooters),\n            total: count(this.groups, includeFooters)\n        };\n    };\n    GroupBindingDirective.prototype.applyState = function (_a) {\n        var skip = _a.skip, take = _a.take, sort = _a.sort, group = _a.group, filter = _a.filter;\n        this.skip = skip;\n        this.state.take = take;\n        // this.pageSize = take; // do need to update take as the process with slice correctly\n        this.sort = sort;\n        this.group = group;\n        this.filter = filter;\n    };\n    return GroupBindingDirective;\n}(DataBindingDirective));\nexport { GroupBindingDirective };\n",null]}