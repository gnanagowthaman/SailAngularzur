{"remainingRequest":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-drawing/dist/es/shapes/path.js","dependencies":[{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@progress/kendo-drawing/dist/es/shapes/path.js","mtime":1529128648283},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/cache-loader/dist/cjs.js","mtime":1529128679567},{"path":"/home/vahai/Desktop/jun16/SailAngularzur/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport Paintable from '../mixins/paintable';\nimport Measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\n\nvar Path = (function (Element) {\n    function Path(options) {\n        Element.call(this, options);\n        this.segments = new GeometryElementsArray();\n        this.segments.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke(\"#000\");\n\n            if (!defined(this.options.stroke.lineJoin)) {\n                this.options.set(\"stroke.lineJoin\", \"miter\");\n            }\n        }\n    }\n\n    if ( Element ) Path.__proto__ = Element;\n    Path.prototype = Object.create( Element && Element.prototype );\n    Path.prototype.constructor = Path;\n\n    Path.prototype.moveTo = function moveTo (x, y) {\n        this.suspend();\n        this.segments.elements([]);\n        this.resume();\n\n        this.lineTo(x, y);\n\n        return this;\n    };\n\n    Path.prototype.lineTo = function lineTo (x, y) {\n        var point = defined(y) ? new Point(x, y) : x;\n        var segment = new Segment(point);\n\n        this.segments.push(segment);\n\n        return this;\n    };\n\n    Path.prototype.curveTo = function curveTo (controlOut, controlIn, point) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var segment = new Segment(point, controlIn);\n            this.suspend();\n            lastSegment.controlOut(controlOut);\n            this.resume();\n\n            this.segments.push(segment);\n        }\n\n        return this;\n    };\n\n    Path.prototype.arc = function arc (startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var anchor = lastSegment.anchor();\n            var start = rad(startAngle);\n            var center = new Point(anchor.x - radiusX * Math.cos(start),\n                anchor.y - radiusY * Math.sin(start));\n            var arc = new Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n            });\n\n            this._addArcSegments(arc);\n        }\n\n        return this;\n    };\n\n    Path.prototype.arcTo = function arcTo (end, rx, ry, largeArc, swipe, rotation) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var anchor = lastSegment.anchor();\n            var arc = Arc.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n            this._addArcSegments(arc);\n        }\n        return this;\n    };\n\n    Path.prototype._addArcSegments = function _addArcSegments (arc) {\n        var this$1 = this;\n\n        this.suspend();\n\n        var curvePoints = arc.curvePoints();\n\n        for (var i = 1; i < curvePoints.length; i += 3) {\n            this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n        }\n\n        this.resume();\n        this.geometryChange();\n    };\n\n    Path.prototype.close = function close () {\n        this.options.closed = true;\n        this.geometryChange();\n\n        return this;\n    };\n\n    Path.prototype.rawBBox = function rawBBox () {\n        return this._bbox();\n    };\n\n    Path.prototype._containsPoint = function _containsPoint (point) {\n        var segments = this.segments;\n        var length = segments.length;\n        var intersectionsCount = 0;\n        var previous, current;\n\n        for (var idx = 1; idx < length; idx++) {\n            previous = segments[idx - 1];\n            current = segments[idx];\n            intersectionsCount += previous._intersectionsTo(current, point);\n        }\n\n        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n        }\n\n        return intersectionsCount % 2 !== 0;\n    };\n\n    Path.prototype._isOnPath = function _isOnPath (point, width) {\n        var segments = this.segments;\n        var length = segments.length;\n        var pathWidth = width || this.options.stroke.width;\n\n        if (length > 1) {\n            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n                return true;\n            }\n\n            for (var idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                    return true;\n                }\n            }\n\n            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    Path.prototype._bbox = function _bbox (matrix) {\n        var segments = this.segments;\n        var length = segments.length;\n        var boundingBox;\n\n        if (length === 1) {\n            var anchor = segments[0].anchor().transformCopy(matrix);\n            boundingBox = new Rect(anchor, Size.ZERO);\n        } else if (length > 0) {\n            for (var i = 1; i < length; i++) {\n                var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n                if (boundingBox) {\n                    boundingBox = Rect.union(boundingBox, segmentBox);\n                } else {\n                    boundingBox = segmentBox;\n                }\n            }\n        }\n\n        return boundingBox;\n    };\n\n    Path.fromRect = function fromRect (rect, options) {\n        return new Path(options)\n            .moveTo(rect.topLeft())\n            .lineTo(rect.topRight())\n            .lineTo(rect.bottomRight())\n            .lineTo(rect.bottomLeft())\n            .close();\n    };\n\n    Path.fromPoints = function fromPoints (points, options) {\n        if (points) {\n            var path = new Path(options);\n\n            for (var i = 0; i < points.length; i++) {\n                var point = Point.create(points[i]);\n                if (point) {\n                    if (i === 0) {\n                        path.moveTo(point);\n                    } else {\n                        path.lineTo(point);\n                    }\n                }\n            }\n\n            return path;\n        }\n    };\n\n    Path.fromArc = function fromArc (arc, options) {\n        var path = new Path(options);\n        var startAngle = arc.startAngle;\n        var start = arc.pointAt(startAngle);\n        path.moveTo(start.x, start.y);\n        path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n        return path;\n    };\n\n    return Path;\n}(Element));\n\nPath.prototype.nodeType = \"Path\";\n\nPaintable.extend(Path.prototype);\nMeasurable.extend(Path.prototype);\n\nexport default Path;",null]}